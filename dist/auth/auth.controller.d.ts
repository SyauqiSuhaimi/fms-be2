/// <reference types="multer" />
import { WorkTradeService } from "../workTrade/worktrade.service";
import { Response, Request } from "express";
import { AuthService } from "./auth.service";
import { JwtService } from "@nestjs/jwt";
import { userType } from "./usertype.entity";
import { Department } from "../entities/department.entity";
import { Maintenance } from "../entities/maintenance.entity";
import { Company } from "../entities/company.entity";
import { Case } from "../entities/case.entity";
import { Technician } from "../entities/technician.entity";
import { WorkTrade } from "../entities/workTrade.entity";
import { GeneralService } from "../helper/general.service";
export declare class AuthController {
    private readonly authService;
    private jwtService;
    private GeneralService;
    private worktradeservice;
    constructor(authService: AuthService, jwtService: JwtService, GeneralService: GeneralService, worktradeservice: WorkTradeService);
    getUser(worktradeId: number): Promise<any[]>;
    getUserCompany(request: Request): Promise<import("./user.entity").User[]>;
    getUserDepartment(request: Request): Promise<any[]>;
    typeAdd(status: number, type: string, name: string): Promise<userType>;
    featureAdd(name: string, link: string, category: string, type: string): Promise<import("./feature.entity").Feature>;
    user(request: Request): Promise<{
        id: number;
        name: string;
        email: string;
        rate: number;
        ot1: number;
        ot2: number;
        ot3: number;
        image_file: string;
        mobile_no: string;
        usertypes: userType;
        department: Department;
        maintenance: Maintenance[];
        grouplist: string;
        company: Company;
        cases: Case[];
        casemaintained: Technician[];
        caseassigned: Technician[];
        worktrade: WorkTrade[];
        casehistory: import("../entities/caseHistory.entity").CaseHistory[];
        user_casehistory: import("../entities/caseHistory.entity").CaseHistory[];
        news: import("../entities/news.entity").News[];
        ppmchecklist: import("../entities/ppmChecklist.entity").ppmChecklist[];
        tempPpm: Case[];
        notifications: import("../entities/notification.entity").Notifications;
        workspace: import("../entities/workspace.entity").workspace[];
        designation: string;
        user_work_id: string;
        user_unit: string;
    }>;
    changePassword(request: Request, userData: any): Promise<{
        success: boolean;
        msg: string;
    }>;
    delete(request: Request, id: number): Promise<any>;
    typeDelete(request: Request, id: number): Promise<any>;
    permissionDelete(request: Request, id: number): Promise<any>;
    featureDelete(request: Request, id: number): Promise<any>;
    getall(request: Request): Promise<{
        [n: number]: import("./user.entity").User;
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): import("./user.entity").User;
        push(...items: import("./user.entity").User[]): number;
        concat(...items: ConcatArray<import("./user.entity").User>[]): import("./user.entity").User[];
        concat(...items: (import("./user.entity").User | ConcatArray<import("./user.entity").User>)[]): import("./user.entity").User[];
        join(separator?: string): string;
        reverse(): import("./user.entity").User[];
        shift(): import("./user.entity").User;
        slice(start?: number, end?: number): import("./user.entity").User[];
        sort(compareFn?: (a: import("./user.entity").User, b: import("./user.entity").User) => number): import("./user.entity").User[];
        splice(start: number, deleteCount?: number): import("./user.entity").User[];
        splice(start: number, deleteCount: number, ...items: import("./user.entity").User[]): import("./user.entity").User[];
        unshift(...items: import("./user.entity").User[]): number;
        indexOf(searchElement: import("./user.entity").User, fromIndex?: number): number;
        lastIndexOf(searchElement: import("./user.entity").User, fromIndex?: number): number;
        every<S extends import("./user.entity").User>(predicate: (value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => U, thisArg?: any): U[];
        filter<S_1 extends import("./user.entity").User>(predicate: (value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => unknown, thisArg?: any): import("./user.entity").User[];
        reduce(callbackfn: (previousValue: import("./user.entity").User, currentValue: import("./user.entity").User, currentIndex: number, array: import("./user.entity").User[]) => import("./user.entity").User): import("./user.entity").User;
        reduce(callbackfn: (previousValue: import("./user.entity").User, currentValue: import("./user.entity").User, currentIndex: number, array: import("./user.entity").User[]) => import("./user.entity").User, initialValue: import("./user.entity").User): import("./user.entity").User;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: import("./user.entity").User, currentIndex: number, array: import("./user.entity").User[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: import("./user.entity").User, currentValue: import("./user.entity").User, currentIndex: number, array: import("./user.entity").User[]) => import("./user.entity").User): import("./user.entity").User;
        reduceRight(callbackfn: (previousValue: import("./user.entity").User, currentValue: import("./user.entity").User, currentIndex: number, array: import("./user.entity").User[]) => import("./user.entity").User, initialValue: import("./user.entity").User): import("./user.entity").User;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: import("./user.entity").User, currentIndex: number, array: import("./user.entity").User[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends import("./user.entity").User>(predicate: (this: void, value: import("./user.entity").User, index: number, obj: import("./user.entity").User[]) => value is S_2, thisArg?: any): S_2;
        find(predicate: (value: import("./user.entity").User, index: number, obj: import("./user.entity").User[]) => unknown, thisArg?: any): import("./user.entity").User;
        findIndex(predicate: (value: import("./user.entity").User, index: number, obj: import("./user.entity").User[]) => unknown, thisArg?: any): number;
        fill(value: import("./user.entity").User, start?: number, end?: number): import("./user.entity").User[];
        copyWithin(target: number, start: number, end?: number): import("./user.entity").User[];
        entries(): IterableIterator<[number, import("./user.entity").User]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<import("./user.entity").User>;
        includes(searchElement: import("./user.entity").User, fromIndex?: number): boolean;
        flatMap<U_3, This = undefined>(callback: (this: This, value: import("./user.entity").User, index: number, array: import("./user.entity").User[]) => U_3 | readonly U_3[], thisArg?: This): U_3[];
        flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
        [Symbol.iterator](): IterableIterator<import("./user.entity").User>;
        [Symbol.unscopables](): {
            copyWithin: boolean;
            entries: boolean;
            fill: boolean;
            find: boolean;
            findIndex: boolean;
            keys: boolean;
            values: boolean;
        };
        at(index: number): import("./user.entity").User;
    }>;
    getAllUserbyCompany(request: Request, id?: number | null): Promise<{
        id: number;
        name: string;
        email: string;
        rate: number;
        ot1: number;
        ot2: number;
        ot3: number;
        image_file: string;
        mobile_no: string;
        usertypes: userType;
        department: Department;
        maintenance: Maintenance[];
        grouplist: string;
        company: Company;
        cases: Case[];
        casemaintained: Technician[];
        caseassigned: Technician[];
        worktrade: WorkTrade[];
        casehistory: import("../entities/caseHistory.entity").CaseHistory[];
        user_casehistory: import("../entities/caseHistory.entity").CaseHistory[];
        news: import("../entities/news.entity").News[];
        ppmchecklist: import("../entities/ppmChecklist.entity").ppmChecklist[];
        tempPpm: Case[];
        notifications: import("../entities/notification.entity").Notifications;
        workspace: import("../entities/workspace.entity").workspace[];
        designation: string;
        user_work_id: string;
        user_unit: string;
    }[]>;
    getalltype(request: Request): Promise<{
        [n: number]: userType;
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): userType;
        push(...items: userType[]): number;
        concat(...items: ConcatArray<userType>[]): userType[];
        concat(...items: (userType | ConcatArray<userType>)[]): userType[];
        join(separator?: string): string;
        reverse(): userType[];
        shift(): userType;
        slice(start?: number, end?: number): userType[];
        sort(compareFn?: (a: userType, b: userType) => number): userType[];
        splice(start: number, deleteCount?: number): userType[];
        splice(start: number, deleteCount: number, ...items: userType[]): userType[];
        unshift(...items: userType[]): number;
        indexOf(searchElement: userType, fromIndex?: number): number;
        lastIndexOf(searchElement: userType, fromIndex?: number): number;
        every<S extends userType>(predicate: (value: userType, index: number, array: userType[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: userType, index: number, array: userType[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: userType, index: number, array: userType[]) => U, thisArg?: any): U[];
        filter<S_1 extends userType>(predicate: (value: userType, index: number, array: userType[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): userType[];
        reduce(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType): userType;
        reduce(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType, initialValue: userType): userType;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: userType, currentIndex: number, array: userType[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType): userType;
        reduceRight(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType, initialValue: userType): userType;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: userType, currentIndex: number, array: userType[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends userType>(predicate: (this: void, value: userType, index: number, obj: userType[]) => value is S_2, thisArg?: any): S_2;
        find(predicate: (value: userType, index: number, obj: userType[]) => unknown, thisArg?: any): userType;
        findIndex(predicate: (value: userType, index: number, obj: userType[]) => unknown, thisArg?: any): number;
        fill(value: userType, start?: number, end?: number): userType[];
        copyWithin(target: number, start: number, end?: number): userType[];
        entries(): IterableIterator<[number, userType]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<userType>;
        includes(searchElement: userType, fromIndex?: number): boolean;
        flatMap<U_3, This = undefined>(callback: (this: This, value: userType, index: number, array: userType[]) => U_3 | readonly U_3[], thisArg?: This): U_3[];
        flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
        [Symbol.iterator](): IterableIterator<userType>;
        [Symbol.unscopables](): {
            copyWithin: boolean;
            entries: boolean;
            fill: boolean;
            find: boolean;
            findIndex: boolean;
            keys: boolean;
            values: boolean;
        };
        at(index: number): userType;
    }>;
    typeByCompany(request: Request): Promise<{
        [n: number]: userType;
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): userType;
        push(...items: userType[]): number;
        concat(...items: ConcatArray<userType>[]): userType[];
        concat(...items: (userType | ConcatArray<userType>)[]): userType[];
        join(separator?: string): string;
        reverse(): userType[];
        shift(): userType;
        slice(start?: number, end?: number): userType[];
        sort(compareFn?: (a: userType, b: userType) => number): userType[];
        splice(start: number, deleteCount?: number): userType[];
        splice(start: number, deleteCount: number, ...items: userType[]): userType[];
        unshift(...items: userType[]): number;
        indexOf(searchElement: userType, fromIndex?: number): number;
        lastIndexOf(searchElement: userType, fromIndex?: number): number;
        every<S extends userType>(predicate: (value: userType, index: number, array: userType[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: userType, index: number, array: userType[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: userType, index: number, array: userType[]) => U, thisArg?: any): U[];
        filter<S_1 extends userType>(predicate: (value: userType, index: number, array: userType[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): userType[];
        reduce(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType): userType;
        reduce(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType, initialValue: userType): userType;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: userType, currentIndex: number, array: userType[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType): userType;
        reduceRight(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType, initialValue: userType): userType;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: userType, currentIndex: number, array: userType[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends userType>(predicate: (this: void, value: userType, index: number, obj: userType[]) => value is S_2, thisArg?: any): S_2;
        find(predicate: (value: userType, index: number, obj: userType[]) => unknown, thisArg?: any): userType;
        findIndex(predicate: (value: userType, index: number, obj: userType[]) => unknown, thisArg?: any): number;
        fill(value: userType, start?: number, end?: number): userType[];
        copyWithin(target: number, start: number, end?: number): userType[];
        entries(): IterableIterator<[number, userType]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<userType>;
        includes(searchElement: userType, fromIndex?: number): boolean;
        flatMap<U_3, This = undefined>(callback: (this: This, value: userType, index: number, array: userType[]) => U_3 | readonly U_3[], thisArg?: This): U_3[];
        flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
        [Symbol.iterator](): IterableIterator<userType>;
        [Symbol.unscopables](): {
            copyWithin: boolean;
            entries: boolean;
            fill: boolean;
            find: boolean;
            findIndex: boolean;
            keys: boolean;
            values: boolean;
        };
        at(index: number): userType;
    }>;
    typeByCompany2(request: Request, id: number): Promise<userType[]>;
    findAllTypeuser(request: Request): Promise<{
        [n: number]: userType;
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): userType;
        push(...items: userType[]): number;
        concat(...items: ConcatArray<userType>[]): userType[];
        concat(...items: (userType | ConcatArray<userType>)[]): userType[];
        join(separator?: string): string;
        reverse(): userType[];
        shift(): userType;
        slice(start?: number, end?: number): userType[];
        sort(compareFn?: (a: userType, b: userType) => number): userType[];
        splice(start: number, deleteCount?: number): userType[];
        splice(start: number, deleteCount: number, ...items: userType[]): userType[];
        unshift(...items: userType[]): number;
        indexOf(searchElement: userType, fromIndex?: number): number;
        lastIndexOf(searchElement: userType, fromIndex?: number): number;
        every<S extends userType>(predicate: (value: userType, index: number, array: userType[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: userType, index: number, array: userType[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: userType, index: number, array: userType[]) => U, thisArg?: any): U[];
        filter<S_1 extends userType>(predicate: (value: userType, index: number, array: userType[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: userType, index: number, array: userType[]) => unknown, thisArg?: any): userType[];
        reduce(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType): userType;
        reduce(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType, initialValue: userType): userType;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: userType, currentIndex: number, array: userType[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType): userType;
        reduceRight(callbackfn: (previousValue: userType, currentValue: userType, currentIndex: number, array: userType[]) => userType, initialValue: userType): userType;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: userType, currentIndex: number, array: userType[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends userType>(predicate: (this: void, value: userType, index: number, obj: userType[]) => value is S_2, thisArg?: any): S_2;
        find(predicate: (value: userType, index: number, obj: userType[]) => unknown, thisArg?: any): userType;
        findIndex(predicate: (value: userType, index: number, obj: userType[]) => unknown, thisArg?: any): number;
        fill(value: userType, start?: number, end?: number): userType[];
        copyWithin(target: number, start: number, end?: number): userType[];
        entries(): IterableIterator<[number, userType]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<userType>;
        includes(searchElement: userType, fromIndex?: number): boolean;
        flatMap<U_3, This = undefined>(callback: (this: This, value: userType, index: number, array: userType[]) => U_3 | readonly U_3[], thisArg?: This): U_3[];
        flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
        [Symbol.iterator](): IterableIterator<userType>;
        [Symbol.unscopables](): {
            copyWithin: boolean;
            entries: boolean;
            fill: boolean;
            find: boolean;
            findIndex: boolean;
            keys: boolean;
            values: boolean;
        };
        at(index: number): userType;
    }>;
    findUsertypeFeature(request: Request): Promise<any>;
    getallfeature(request: Request): Promise<{
        [n: number]: any;
        length: number;
        toString(): string;
        toLocaleString(): string;
        pop(): any;
        push(...items: any[]): number;
        concat(...items: ConcatArray<any>[]): any[];
        concat(...items: any[]): any[];
        join(separator?: string): string;
        reverse(): any[];
        shift(): any;
        slice(start?: number, end?: number): any[];
        sort(compareFn?: (a: any, b: any) => number): any[];
        splice(start: number, deleteCount?: number): any[];
        splice(start: number, deleteCount: number, ...items: any[]): any[];
        unshift(...items: any[]): number;
        indexOf(searchElement: any, fromIndex?: number): number;
        lastIndexOf(searchElement: any, fromIndex?: number): number;
        every<S extends any>(predicate: (value: any, index: number, array: any[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: any, index: number, array: any[]) => U, thisArg?: any): U[];
        filter<S_1 extends any>(predicate: (value: any, index: number, array: any[]) => value is S_1, thisArg?: any): S_1[];
        filter(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): any[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any;
        reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: any, currentIndex: number, array: any[]) => U_1, initialValue: U_1): U_1;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any;
        reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: any, currentIndex: number, array: any[]) => U_2, initialValue: U_2): U_2;
        find<S_2 extends any>(predicate: (this: void, value: any, index: number, obj: any[]) => value is S_2, thisArg?: any): S_2;
        find(predicate: (value: any, index: number, obj: any[]) => unknown, thisArg?: any): any;
        findIndex(predicate: (value: any, index: number, obj: any[]) => unknown, thisArg?: any): number;
        fill(value: any, start?: number, end?: number): any[];
        copyWithin(target: number, start: number, end?: number): any[];
        entries(): IterableIterator<[number, any]>;
        keys(): IterableIterator<number>;
        values(): IterableIterator<any>;
        includes(searchElement: any, fromIndex?: number): boolean;
        flatMap<U_3, This = undefined>(callback: (this: This, value: any, index: number, array: any[]) => U_3 | readonly U_3[], thisArg?: This): U_3[];
        flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
        [Symbol.iterator](): IterableIterator<any>;
        [Symbol.unscopables](): {
            copyWithin: boolean;
            entries: boolean;
            fill: boolean;
            find: boolean;
            findIndex: boolean;
            keys: boolean;
            values: boolean;
        };
        at(index: number): any;
    }>;
    updatePost2(request: Request, id: number, userdata: any, files: Array<Express.Multer.File>): Promise<any>;
    updatePost(request: Request, id: number, userdata: any): Promise<any>;
    createcase(body: any, files: Array<Express.Multer.File>): Promise<import("./user.entity").User>;
    typeUpdate(request: Request, id: number, userdata: any): Promise<any>;
    permissionUpdate(request: Request, id: number, permissiondata: any): Promise<any>;
    featureUpdate(request: Request, id: number, featuredata: any): Promise<any>;
    userAdd(body: any, files: Array<Express.Multer.File>): Promise<import("./user.entity").User>;
    quickReg(body: any): Promise<import("./user.entity").User>;
    changeImage(body: any, files: Array<Express.Multer.File>, request: Request): Promise<{
        success: boolean;
        msg: string;
    }>;
    resetPassword(body: any): Promise<any>;
    downloadexcel(res: Response): Promise<void>;
    downloadExcelData(res: Response, request: Request): Promise<void>;
    uploadFile(body: any, files: any, request: Request): Promise<void>;
    testdownloadExcelData(res: Response): Promise<void>;
}
export declare class AuthController2 {
    private readonly authService;
    private jwtService;
    constructor(authService: AuthService, jwtService: JwtService);
    login(email: string, password: string, response: Response): Promise<{
        success: boolean;
        message: string;
        usertype?: undefined;
        company?: undefined;
    } | {
        success: boolean;
        message: string;
        usertype: string;
        company: Company;
    }>;
    logout(response: Response): Promise<{
        message: string;
    }>;
}
